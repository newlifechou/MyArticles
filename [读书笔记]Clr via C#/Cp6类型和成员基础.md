# Cp6类型和成员基础
## 成员
常量；字段（静态字段和实例字段）；实例构造器；类型构造器（用于静态字段的构造）；方法（静态方法和实例方法）；操作符重载（本质是一个方法）；转换操作符；属性（本质还是方法）；事件（委托）；类型（嵌套类）；  
## 类型的可见性
public,private,protected,internal,sealed,默认的类是internal。  
## 友元程序集
这部分看看就行了  
## 成员的可访问性
private protected(对应clr是Family)，internal（对应clr是assembly），public,protected internal;默认是private；  
## 静态类
静态类一般用作工具类，组合一组相关的成员在一起。  
限制：
* 只能派生自Object  
* 不能实现任何接口
* 只能定义静态成员
* 不能作为字段，方法参数或者局部变量使用  

## 分部类，分部结构和分部接口
partial关键词，作用就是多个文件好管理，代码拆分。  

## 组件，多态和版本控制
了解组件的含义  
主版本，次版本，内部版本，修订号；前两个代表连续，稳定的程序集，后两个代表对这个功能集的一次维护。  
CLR是连续带看版本号的，不同的版本号视为不同的程序集。  
区分abstract，virtual，override，sealed，new的含义，其实很好理解的；  
## CLR如何调用虚方法，属性和事件
这块很有意思，直接看书上，结合IL来讲解，比较清楚。call,callvirt指令。只是书上描述的不是很清楚， 暂时没看原版，不知道是不是翻译问题。 网上看了一个人的介绍，call=调用由传递的方法说明符指示的方法，callvirt=对对象调用后期的绑定方法。感觉是可以这么理解。 
设计类的时候，尽量减少虚方法的定义，因为性能原因，还有基类丧失对虚成员的控制。  
## 合理使用类型的可见性和成员的可访问性
这里作者认为默认的非sealed类不好，从提高编译后代码性能，安全性和版本控制的角度来考虑的，有道理，但是实际开发中还是习惯不sealed，哈哈。  
作者不喜欢嵌套类，我也不喜欢。  
## 对类型进行版本控制的时候的虚方法的处理
这里主要解释了new和override的用法，当然尽量让方法名称不一样吧。


